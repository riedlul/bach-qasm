/*
 * generated by Xtext 2.30.0
 */
package org.xtext.openqasm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.openqasm.openQASM3.Designator;
import org.xtext.openqasm.openQASM3.Expression;
import org.xtext.openqasm.openQASM3.ExpressionList;
import org.xtext.openqasm.openQASM3.GateCallStatement;
import org.xtext.openqasm.openQASM3.IfStatement;
import org.xtext.openqasm.openQASM3.IncludeStatement;
import org.xtext.openqasm.openQASM3.IndexedIdentifier;
import org.xtext.openqasm.openQASM3.Literal;
import org.xtext.openqasm.openQASM3.MultiplicativeExpression;
import org.xtext.openqasm.openQASM3.OpenQASM3Package;
import org.xtext.openqasm.openQASM3.Program;
import org.xtext.openqasm.openQASM3.QubitType;
import org.xtext.openqasm.openQASM3.Scope;
import org.xtext.openqasm.openQASM3.UnaryExpression;
import org.xtext.openqasm.openQASM3.Version;
import org.xtext.openqasm.services.OpenQASM3GrammarAccess;

@SuppressWarnings("all")
public class OpenQASM3SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OpenQASM3GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OpenQASM3Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OpenQASM3Package.DESIGNATOR:
				sequence_Designator(context, (Designator) semanticObject); 
				return; 
			case OpenQASM3Package.EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIndexOperatorRule()) {
					sequence_Expression_IndexOperator(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case OpenQASM3Package.EXPRESSION_LIST:
				sequence_ExpressionList(context, (ExpressionList) semanticObject); 
				return; 
			case OpenQASM3Package.GATE_CALL_STATEMENT:
				sequence_GateCallStatement(context, (GateCallStatement) semanticObject); 
				return; 
			case OpenQASM3Package.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case OpenQASM3Package.INCLUDE_STATEMENT:
				sequence_IncludeStatement(context, (IncludeStatement) semanticObject); 
				return; 
			case OpenQASM3Package.INDEXED_IDENTIFIER:
				if (rule == grammarAccess.getGateOperandListRule()) {
					sequence_GateOperandList_IndexedIdentifier(context, (IndexedIdentifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIndexedIdentifierRule()
						|| rule == grammarAccess.getGateOperandRule()) {
					sequence_IndexedIdentifier(context, (IndexedIdentifier) semanticObject); 
					return; 
				}
				else break;
			case OpenQASM3Package.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case OpenQASM3Package.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case OpenQASM3Package.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case OpenQASM3Package.QUBIT_TYPE:
				if (rule == grammarAccess.getQubitTypeRule()) {
					sequence_QubitType(context, (QubitType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getQuantumDeclarationStatementRule()
						|| rule == grammarAccess.getStatementOrScopeRule()) {
					sequence_QubitType_quantumDeclarationStatement(context, (QubitType) semanticObject); 
					return; 
				}
				else break;
			case OpenQASM3Package.SCOPE:
				sequence_Scope(context, (Scope) semanticObject); 
				return; 
			case OpenQASM3Package.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case OpenQASM3Package.VERSION:
				sequence_Version(context, (Version) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Designator returns Designator
	 *
	 * Constraint:
	 *     e=Expression?
	 * </pre>
	 */
	protected void sequence_Designator(ISerializationContext context, Designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionList returns ExpressionList
	 *
	 * Constraint:
	 *     (e1=Expression e2+=Expression*)
	 * </pre>
	 */
	protected void sequence_ExpressionList(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (exprs+=Expression | ltrs+=Literal | unExpressions+=UnaryExpression | multExpressions+=MultiplicativeExpression)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IndexOperator returns Expression
	 *
	 * Constraint:
	 *     ((exprs+=Expression | ltrs+=Literal | unExpressions+=UnaryExpression | multExpressions+=MultiplicativeExpression) e+=Expression*)
	 * </pre>
	 */
	protected void sequence_Expression_IndexOperator(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns GateCallStatement
	 *     GateCallStatement returns GateCallStatement
	 *     statementOrScope returns GateCallStatement
	 *
	 * Constraint:
	 *     (gate=ID el=ExpressionList? gateList=GateOperandList scope=Scope?)
	 * </pre>
	 */
	protected void sequence_GateCallStatement(ISerializationContext context, GateCallStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GateOperandList returns IndexedIdentifier
	 *
	 * Constraint:
	 *     (gateName=ID io+=IndexOperator* extraGO+=GateOperand*)
	 * </pre>
	 */
	protected void sequence_GateOperandList_IndexedIdentifier(ISerializationContext context, IndexedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *     statementOrScope returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression if_body=statementOrScope)
	 * </pre>
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.IF_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.IF_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.IF_STATEMENT__IF_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.IF_STATEMENT__IF_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfStatementAccess().getIf_bodyStatementOrScopeParserRuleCall_4_0(), semanticObject.getIf_body());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IncludeStatement
	 *     statementOrScope returns IncludeStatement
	 *     IncludeStatement returns IncludeStatement
	 *
	 * Constraint:
	 *     libName=STRING
	 * </pre>
	 */
	protected void sequence_IncludeStatement(ISerializationContext context, IncludeStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.INCLUDE_STATEMENT__LIB_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.INCLUDE_STATEMENT__LIB_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeStatementAccess().getLibNameSTRINGTerminalRuleCall_1_0(), semanticObject.getLibName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IndexedIdentifier returns IndexedIdentifier
	 *     GateOperand returns IndexedIdentifier
	 *
	 * Constraint:
	 *     (gateName=ID io+=IndexOperator*)
	 * </pre>
	 */
	protected void sequence_IndexedIdentifier(ISerializationContext context, IndexedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     l=FloatLiteral?
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (l1+=Literal l1+=Literal l1+=Literal*)
	 * </pre>
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     ((version=Version statements+=Statement+) | statements+=Statement+)?
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QubitType returns QubitType
	 *
	 * Constraint:
	 *     d=Designator
	 * </pre>
	 */
	protected void sequence_QubitType(ISerializationContext context, QubitType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.QUBIT_TYPE__D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.QUBIT_TYPE__D));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQubitTypeAccess().getDDesignatorParserRuleCall_1_0(), semanticObject.getD());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns QubitType
	 *     quantumDeclarationStatement returns QubitType
	 *     statementOrScope returns QubitType
	 *
	 * Constraint:
	 *     (d=Designator name=ID)
	 * </pre>
	 */
	protected void sequence_QubitType_quantumDeclarationStatement(ISerializationContext context, QubitType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.QUBIT_TYPE__D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.QUBIT_TYPE__D));
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.QUBIT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.QUBIT_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQubitTypeAccess().getDDesignatorParserRuleCall_1_0(), semanticObject.getD());
		feeder.accept(grammarAccess.getQuantumDeclarationStatementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     statementOrScope returns Scope
	 *     Scope returns Scope
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_Scope(ISerializationContext context, Scope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (op=UnaryOperator l=Literal)
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.UNARY_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.UNARY_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.UNARY_EXPRESSION__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.UNARY_EXPRESSION__L));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpUnaryOperatorParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getLLiteralParserRuleCall_1_0(), semanticObject.getL());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Version returns Version
	 *
	 * Constraint:
	 *     versionNumber=FloatLiteral
	 * </pre>
	 */
	protected void sequence_Version(ISerializationContext context, Version semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenQASM3Package.Literals.VERSION__VERSION_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenQASM3Package.Literals.VERSION__VERSION_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionAccess().getVersionNumberFloatLiteralParserRuleCall_0_1_0(), semanticObject.getVersionNumber());
		feeder.finish();
	}
	
	
}
