/*
 * generated by Xtext 2.30.0
 */
package org.xtext.openqasm.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class OpenQASM3GrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVersionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVersionVersionParserRuleCall_0_0 = (RuleCall)cVersionAssignment_0.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		
		//Program:
		//    version=Version?
		//    statements+=(Statement)*;
		@Override public ParserRule getRule() { return rule; }
		
		//version=Version?
		//statements+=(Statement)*
		public Group getGroup() { return cGroup; }
		
		//version=Version?
		public Assignment getVersionAssignment_0() { return cVersionAssignment_0; }
		
		//Version
		public RuleCall getVersionVersionParserRuleCall_0_0() { return cVersionVersionParserRuleCall_0_0; }
		
		//statements+=(Statement)*
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//(Statement)
		public RuleCall getStatementsStatementParserRuleCall_1_0() { return cStatementsStatementParserRuleCall_1_0; }
	}
	public class VersionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Version");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cOPENQASMKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cVersionNumberAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cVersionNumberFloatLiteralParserRuleCall_0_1_0 = (RuleCall)cVersionNumberAssignment_0_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Version:
		//    ('OPENQASM' versionNumber=FloatLiteral) SEMICOLON
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//('OPENQASM' versionNumber=FloatLiteral) SEMICOLON
		public Group getGroup() { return cGroup; }
		
		//('OPENQASM' versionNumber=FloatLiteral)
		public Group getGroup_0() { return cGroup_0; }
		
		//'OPENQASM'
		public Keyword getOPENQASMKeyword_0_0() { return cOPENQASMKeyword_0_0; }
		
		//versionNumber=FloatLiteral
		public Assignment getVersionNumberAssignment_0_1() { return cVersionNumberAssignment_0_1; }
		
		//FloatLiteral
		public RuleCall getVersionNumberFloatLiteralParserRuleCall_0_1_0() { return cVersionNumberFloatLiteralParserRuleCall_0_1_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1() { return cSEMICOLONTerminalRuleCall_1; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIncludeStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantumDeclarationStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGateCallStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Statement:
		//    IncludeStatement
		//    |quantumDeclarationStatement
		//    |GateCallStatement
		//    |IfStatement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//IncludeStatement
		//|quantumDeclarationStatement
		//|GateCallStatement
		//|IfStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IncludeStatement
		public RuleCall getIncludeStatementParserRuleCall_0() { return cIncludeStatementParserRuleCall_0; }
		
		//quantumDeclarationStatement
		public RuleCall getQuantumDeclarationStatementParserRuleCall_1() { return cQuantumDeclarationStatementParserRuleCall_1; }
		
		//GateCallStatement
		public RuleCall getGateCallStatementParserRuleCall_2() { return cGateCallStatementParserRuleCall_2; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_3() { return cIfStatementParserRuleCall_3; }
	}
	public class QuantumDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.quantumDeclarationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQubitTypeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//quantumDeclarationStatement:
		//    QubitType name=ID SEMICOLON
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//QubitType name=ID SEMICOLON
		public Group getGroup() { return cGroup; }
		
		//QubitType
		public RuleCall getQubitTypeParserRuleCall_0() { return cQubitTypeParserRuleCall_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2() { return cSEMICOLONTerminalRuleCall_2; }
	}
	public class GateCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.GateCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cGateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGateIDTerminalRuleCall_1_0 = (RuleCall)cGateAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cLPARENTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cElAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElExpressionListParserRuleCall_2_1_0 = (RuleCall)cElAssignment_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Assignment cGateListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cGateListGateOperandListParserRuleCall_3_0 = (RuleCall)cGateListAssignment_3.eContents().get(0);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cScopeAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cScopeScopeParserRuleCall_4_0_0 = (RuleCall)cScopeAssignment_4_0.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1 = (RuleCall)cAlternatives_4.eContents().get(1);
		
		//GateCallStatement:
		//    ('gate')? gate=ID (LPAREN el=ExpressionList? RPAREN)? gateList=GateOperandList (( scope=Scope| SEMICOLON ))
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//('gate')? gate=ID (LPAREN el=ExpressionList? RPAREN)? gateList=GateOperandList (( scope=Scope| SEMICOLON ))
		public Group getGroup() { return cGroup; }
		
		//('gate')?
		public Keyword getGateKeyword_0() { return cGateKeyword_0; }
		
		//gate=ID
		public Assignment getGateAssignment_1() { return cGateAssignment_1; }
		
		//ID
		public RuleCall getGateIDTerminalRuleCall_1_0() { return cGateIDTerminalRuleCall_1_0; }
		
		//(LPAREN el=ExpressionList? RPAREN)?
		public Group getGroup_2() { return cGroup_2; }
		
		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_2_0() { return cLPARENTerminalRuleCall_2_0; }
		
		//el=ExpressionList?
		public Assignment getElAssignment_2_1() { return cElAssignment_2_1; }
		
		//ExpressionList
		public RuleCall getElExpressionListParserRuleCall_2_1_0() { return cElExpressionListParserRuleCall_2_1_0; }
		
		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_2_2() { return cRPARENTerminalRuleCall_2_2; }
		
		//gateList=GateOperandList
		public Assignment getGateListAssignment_3() { return cGateListAssignment_3; }
		
		//GateOperandList
		public RuleCall getGateListGateOperandListParserRuleCall_3_0() { return cGateListGateOperandListParserRuleCall_3_0; }
		
		//(( scope=Scope| SEMICOLON ))
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//scope=Scope
		public Assignment getScopeAssignment_4_0() { return cScopeAssignment_4_0; }
		
		//Scope
		public RuleCall getScopeScopeParserRuleCall_4_0_0() { return cScopeScopeParserRuleCall_4_0_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1() { return cSEMICOLONTerminalRuleCall_4_1; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cIf_bodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIf_bodyStatementOrScopeParserRuleCall_4_0 = (RuleCall)cIf_bodyAssignment_4.eContents().get(0);
		
		//IfStatement:
		//    'if' LPAREN condition=Expression RPAREN if_body=statementOrScope;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' LPAREN condition=Expression RPAREN if_body=statementOrScope
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_1() { return cLPARENTerminalRuleCall_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3() { return cRPARENTerminalRuleCall_3; }
		
		//if_body=statementOrScope
		public Assignment getIf_bodyAssignment_4() { return cIf_bodyAssignment_4; }
		
		//statementOrScope
		public RuleCall getIf_bodyStatementOrScopeParserRuleCall_4_0() { return cIf_bodyStatementOrScopeParserRuleCall_4_0; }
	}
	public class StatementOrScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.statementOrScope");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cScopeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		// //(ELSE else_body=statementOrScope)?;
		//statementOrScope:
		//    Statement|Scope
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Statement|Scope
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Statement
		public RuleCall getStatementParserRuleCall_0() { return cStatementParserRuleCall_0; }
		
		//Scope
		public RuleCall getScopeParserRuleCall_1() { return cScopeParserRuleCall_1; }
	}
	public class ScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Scope");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cScopeAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLBRACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final RuleCall cRBRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Scope:
		//    {Scope} LBRACE statements+=Statement* RBRACE;
		@Override public ParserRule getRule() { return rule; }
		
		//{Scope} LBRACE statements+=Statement* RBRACE
		public Group getGroup() { return cGroup; }
		
		//{Scope}
		public Action getScopeAction_0() { return cScopeAction_0; }
		
		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_1() { return cLBRACETerminalRuleCall_1; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }
		
		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_3() { return cRBRACETerminalRuleCall_3; }
	}
	public class ExpressionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.ExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cE1Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cE1ExpressionParserRuleCall_0_0 = (RuleCall)cE1Assignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cE2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cE2ExpressionParserRuleCall_1_1_0 = (RuleCall)cE2Assignment_1_1.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//ExpressionList:
		//    e1=Expression (COMMA e2+=Expression)* COMMA?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//e1=Expression (COMMA e2+=Expression)* COMMA?
		public Group getGroup() { return cGroup; }
		
		//e1=Expression
		public Assignment getE1Assignment_0() { return cE1Assignment_0; }
		
		//Expression
		public RuleCall getE1ExpressionParserRuleCall_0_0() { return cE1ExpressionParserRuleCall_0_0; }
		
		//(COMMA e2+=Expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0() { return cCOMMATerminalRuleCall_1_0; }
		
		//e2+=Expression
		public Assignment getE2Assignment_1_1() { return cE2Assignment_1_1; }
		
		//Expression
		public RuleCall getE2ExpressionParserRuleCall_1_1_0() { return cE2ExpressionParserRuleCall_1_1_0; }
		
		//COMMA?
		public RuleCall getCOMMATerminalRuleCall_2() { return cCOMMATerminalRuleCall_2; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cExprsAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cExprsExpressionParserRuleCall_0_1_0 = (RuleCall)cExprsAssignment_0_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Assignment cLtrsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLtrsLiteralParserRuleCall_1_0 = (RuleCall)cLtrsAssignment_1.eContents().get(0);
		private final Assignment cUnExpressionsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cUnExpressionsUnaryExpressionParserRuleCall_2_0 = (RuleCall)cUnExpressionsAssignment_2.eContents().get(0);
		private final Assignment cMultExpressionsAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cMultExpressionsMultiplicativeExpressionParserRuleCall_3_0 = (RuleCall)cMultExpressionsAssignment_3.eContents().get(0);
		
		//Expression:
		//    LPAREN exprs+=Expression RPAREN
		//    | ltrs+=Literal
		//    | unExpressions+=UnaryExpression
		//    | multExpressions+=MultiplicativeExpression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LPAREN exprs+=Expression RPAREN
		//| ltrs+=Literal
		//| unExpressions+=UnaryExpression
		//| multExpressions+=MultiplicativeExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LPAREN exprs+=Expression RPAREN
		public Group getGroup_0() { return cGroup_0; }
		
		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0_0() { return cLPARENTerminalRuleCall_0_0; }
		
		//exprs+=Expression
		public Assignment getExprsAssignment_0_1() { return cExprsAssignment_0_1; }
		
		//Expression
		public RuleCall getExprsExpressionParserRuleCall_0_1_0() { return cExprsExpressionParserRuleCall_0_1_0; }
		
		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_0_2() { return cRPARENTerminalRuleCall_0_2; }
		
		//ltrs+=Literal
		public Assignment getLtrsAssignment_1() { return cLtrsAssignment_1; }
		
		//Literal
		public RuleCall getLtrsLiteralParserRuleCall_1_0() { return cLtrsLiteralParserRuleCall_1_0; }
		
		//unExpressions+=UnaryExpression
		public Assignment getUnExpressionsAssignment_2() { return cUnExpressionsAssignment_2; }
		
		//UnaryExpression
		public RuleCall getUnExpressionsUnaryExpressionParserRuleCall_2_0() { return cUnExpressionsUnaryExpressionParserRuleCall_2_0; }
		
		//multExpressions+=MultiplicativeExpression
		public Assignment getMultExpressionsAssignment_3() { return cMultExpressionsAssignment_3; }
		
		//MultiplicativeExpression
		public RuleCall getMultExpressionsMultiplicativeExpressionParserRuleCall_3_0() { return cMultExpressionsMultiplicativeExpressionParserRuleCall_3_0; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cLFloatLiteralParserRuleCall_0_0 = (RuleCall)cLAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final RuleCall cDecimalIntegerLiteralParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//Literal:
		//    l= FloatLiteral
		//    | {Literal} STRING
		//    | {Literal} DecimalIntegerLiteral
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//l= FloatLiteral
		//| {Literal} STRING
		//| {Literal} DecimalIntegerLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//l= FloatLiteral
		public Assignment getLAssignment_0() { return cLAssignment_0; }
		
		//FloatLiteral
		public RuleCall getLFloatLiteralParserRuleCall_0_0() { return cLFloatLiteralParserRuleCall_0_0; }
		
		//{Literal} STRING
		public Group getGroup_1() { return cGroup_1; }
		
		//{Literal}
		public Action getLiteralAction_1_0() { return cLiteralAction_1_0; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1_1() { return cSTRINGTerminalRuleCall_1_1; }
		
		//{Literal} DecimalIntegerLiteral
		public Group getGroup_2() { return cGroup_2; }
		
		//{Literal}
		public Action getLiteralAction_2_0() { return cLiteralAction_2_0; }
		
		//DecimalIntegerLiteral
		public RuleCall getDecimalIntegerLiteralParserRuleCall_2_1() { return cDecimalIntegerLiteralParserRuleCall_2_1; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cL1Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cL1LiteralParserRuleCall_0_0 = (RuleCall)cL1Assignment_0.eContents().get(0);
		private final RuleCall cMultiplicativeOperatorParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cL1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cL1LiteralParserRuleCall_2_0 = (RuleCall)cL1Assignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cMultiplicativeOperatorParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cL1Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cL1LiteralParserRuleCall_3_1_0 = (RuleCall)cL1Assignment_3_1.eContents().get(0);
		
		//MultiplicativeExpression:
		//    l1+=Literal MultiplicativeOperator l1+=Literal (MultiplicativeOperator l1+=Literal)*;
		@Override public ParserRule getRule() { return rule; }
		
		//l1+=Literal MultiplicativeOperator l1+=Literal (MultiplicativeOperator l1+=Literal)*
		public Group getGroup() { return cGroup; }
		
		//l1+=Literal
		public Assignment getL1Assignment_0() { return cL1Assignment_0; }
		
		//Literal
		public RuleCall getL1LiteralParserRuleCall_0_0() { return cL1LiteralParserRuleCall_0_0; }
		
		//MultiplicativeOperator
		public RuleCall getMultiplicativeOperatorParserRuleCall_1() { return cMultiplicativeOperatorParserRuleCall_1; }
		
		//l1+=Literal
		public Assignment getL1Assignment_2() { return cL1Assignment_2; }
		
		//Literal
		public RuleCall getL1LiteralParserRuleCall_2_0() { return cL1LiteralParserRuleCall_2_0; }
		
		//(MultiplicativeOperator l1+=Literal)*
		public Group getGroup_3() { return cGroup_3; }
		
		//MultiplicativeOperator
		public RuleCall getMultiplicativeOperatorParserRuleCall_3_0() { return cMultiplicativeOperatorParserRuleCall_3_0; }
		
		//l1+=Literal
		public Assignment getL1Assignment_3_1() { return cL1Assignment_3_1; }
		
		//Literal
		public RuleCall getL1LiteralParserRuleCall_3_1_0() { return cL1LiteralParserRuleCall_3_1_0; }
	}
	public class MultiplicativeOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.MultiplicativeOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cASTERISKTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSLASHTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MultiplicativeOperator:
		//    ASTERISK | SLASH
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ASTERISK | SLASH
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ASTERISK
		public RuleCall getASTERISKTerminalRuleCall_0() { return cASTERISKTerminalRuleCall_0; }
		
		//SLASH
		public RuleCall getSLASHTerminalRuleCall_1() { return cSLASHTerminalRuleCall_1; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpUnaryOperatorParserRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cLAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLLiteralParserRuleCall_1_0 = (RuleCall)cLAssignment_1.eContents().get(0);
		
		//UnaryExpression:
		//    (op=UnaryOperator) l=Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//(op=UnaryOperator) l=Literal
		public Group getGroup() { return cGroup; }
		
		//(op=UnaryOperator)
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//UnaryOperator
		public RuleCall getOpUnaryOperatorParserRuleCall_0_0() { return cOpUnaryOperatorParserRuleCall_0_0; }
		
		//l=Literal
		public Assignment getLAssignment_1() { return cLAssignment_1; }
		
		//Literal
		public RuleCall getLLiteralParserRuleCall_1_0() { return cLLiteralParserRuleCall_1_0; }
	}
	public class UnaryOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTILDETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEXCLAMATION_POINTTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UnaryOperator:
		//    TILDE | EXCLAMATION_POINT;
		@Override public ParserRule getRule() { return rule; }
		
		//TILDE | EXCLAMATION_POINT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TILDE
		public RuleCall getTILDETerminalRuleCall_0() { return cTILDETerminalRuleCall_0; }
		
		//EXCLAMATION_POINT
		public RuleCall getEXCLAMATION_POINTTerminalRuleCall_1() { return cEXCLAMATION_POINTTerminalRuleCall_1; }
	}
	public class IndexOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.IndexOperator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLBRACKETTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cEAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_1_1_0 = (RuleCall)cEAssignment_1_1_1.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cRBRACKETTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//IndexOperator:
		//    LBRACKET
		//    (
		//        Expression (COMMA e+=Expression)* COMMA?
		//    )
		//    RBRACKET
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LBRACKET
		//(
		//    Expression (COMMA e+=Expression)* COMMA?
		//)
		//RBRACKET
		public Group getGroup() { return cGroup; }
		
		//LBRACKET
		public RuleCall getLBRACKETTerminalRuleCall_0() { return cLBRACKETTerminalRuleCall_0; }
		
		//(
		//    Expression (COMMA e+=Expression)* COMMA?
		//)
		public Group getGroup_1() { return cGroup_1; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1_0() { return cExpressionParserRuleCall_1_0; }
		
		//(COMMA e+=Expression)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_1_0() { return cCOMMATerminalRuleCall_1_1_0; }
		
		//e+=Expression
		public Assignment getEAssignment_1_1_1() { return cEAssignment_1_1_1; }
		
		//Expression
		public RuleCall getEExpressionParserRuleCall_1_1_1_0() { return cEExpressionParserRuleCall_1_1_1_0; }
		
		//COMMA?
		public RuleCall getCOMMATerminalRuleCall_1_2() { return cCOMMATerminalRuleCall_1_2; }
		
		//RBRACKET
		public RuleCall getRBRACKETTerminalRuleCall_2() { return cRBRACKETTerminalRuleCall_2; }
	}
	public class IndexedIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.IndexedIdentifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cGateNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cGateNameIDTerminalRuleCall_0_0 = (RuleCall)cGateNameAssignment_0.eContents().get(0);
		private final Assignment cIoAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIoIndexOperatorParserRuleCall_1_0 = (RuleCall)cIoAssignment_1.eContents().get(0);
		
		//IndexedIdentifier:
		//    gateName=ID (io+=IndexOperator)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//gateName=ID (io+=IndexOperator)*
		public Group getGroup() { return cGroup; }
		
		//gateName=ID
		public Assignment getGateNameAssignment_0() { return cGateNameAssignment_0; }
		
		//ID
		public RuleCall getGateNameIDTerminalRuleCall_0_0() { return cGateNameIDTerminalRuleCall_0_0; }
		
		//(io+=IndexOperator)*
		public Assignment getIoAssignment_1() { return cIoAssignment_1; }
		
		//IndexOperator
		public RuleCall getIoIndexOperatorParserRuleCall_1_0() { return cIoIndexOperatorParserRuleCall_1_0; }
	}
	public class GateOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.GateOperand");
		private final RuleCall cIndexedIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//GateOperand:
		//    IndexedIdentifier
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//IndexedIdentifier
		public RuleCall getIndexedIdentifierParserRuleCall() { return cIndexedIdentifierParserRuleCall; }
	}
	public class GateOperandListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.GateOperandList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGateOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cExtraGOAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExtraGOGateOperandParserRuleCall_1_1_0 = (RuleCall)cExtraGOAssignment_1_1.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//GateOperandList:
		//    GateOperand (COMMA extraGO+=GateOperand)* COMMA?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//GateOperand (COMMA extraGO+=GateOperand)* COMMA?
		public Group getGroup() { return cGroup; }
		
		//GateOperand
		public RuleCall getGateOperandParserRuleCall_0() { return cGateOperandParserRuleCall_0; }
		
		//(COMMA extraGO+=GateOperand)*
		public Group getGroup_1() { return cGroup_1; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0() { return cCOMMATerminalRuleCall_1_0; }
		
		//extraGO+=GateOperand
		public Assignment getExtraGOAssignment_1_1() { return cExtraGOAssignment_1_1; }
		
		//GateOperand
		public RuleCall getExtraGOGateOperandParserRuleCall_1_1_0() { return cExtraGOGateOperandParserRuleCall_1_1_0; }
		
		//COMMA?
		public RuleCall getCOMMATerminalRuleCall_2() { return cCOMMATerminalRuleCall_2; }
	}
	public class QubitTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.QubitType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQUBITTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDDesignatorParserRuleCall_1_0 = (RuleCall)cDAssignment_1.eContents().get(0);
		
		//QubitType:
		//     QUBIT d=Designator;
		@Override public ParserRule getRule() { return rule; }
		
		//QUBIT d=Designator
		public Group getGroup() { return cGroup; }
		
		//QUBIT
		public RuleCall getQUBITTerminalRuleCall_0() { return cQUBITTerminalRuleCall_0; }
		
		//d=Designator
		public Assignment getDAssignment_1() { return cDAssignment_1; }
		
		//Designator
		public RuleCall getDDesignatorParserRuleCall_1_0() { return cDDesignatorParserRuleCall_1_0; }
	}
	public class DesignatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.Designator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDesignatorAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLBRACKETTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cEAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEExpressionParserRuleCall_2_0 = (RuleCall)cEAssignment_2.eContents().get(0);
		private final RuleCall cRBRACKETTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Designator:
		//    {Designator} LBRACKET e=Expression? RBRACKET
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Designator} LBRACKET e=Expression? RBRACKET
		public Group getGroup() { return cGroup; }
		
		//{Designator}
		public Action getDesignatorAction_0() { return cDesignatorAction_0; }
		
		//LBRACKET
		public RuleCall getLBRACKETTerminalRuleCall_1() { return cLBRACKETTerminalRuleCall_1; }
		
		//e=Expression?
		public Assignment getEAssignment_2() { return cEAssignment_2; }
		
		//Expression
		public RuleCall getEExpressionParserRuleCall_2_0() { return cEExpressionParserRuleCall_2_0; }
		
		//RBRACKET
		public RuleCall getRBRACKETTerminalRuleCall_3() { return cRBRACKETTerminalRuleCall_3; }
	}
	public class FloatLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.FloatLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cDecimalIntegerLiteralParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cDecimalIntegerLiteralParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cEKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final RuleCall cDecimalIntegerLiteralParserRuleCall_0_3_1 = (RuleCall)cGroup_0_3.eContents().get(1);
		private final Group cGroup_0_3_2 = (Group)cGroup_0_3.eContents().get(2);
		private final RuleCall cDOTTerminalRuleCall_0_3_2_0 = (RuleCall)cGroup_0_3_2.eContents().get(0);
		private final RuleCall cDecimalIntegerLiteralParserRuleCall_0_3_2_1 = (RuleCall)cGroup_0_3_2.eContents().get(1);
		private final Keyword cPiKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//FloatLiteral:
		//    //( MINUS? DecimalIntegerLiteral DOT DecimalIntegerLiteral? ((('e-' | 'e')) DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
		//    ( DecimalIntegerLiteral DOT DecimalIntegerLiteral? (('e') DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
		//    |'pi'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////( MINUS? DecimalIntegerLiteral DOT DecimalIntegerLiteral? ((('e-' | 'e')) DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
		//( DecimalIntegerLiteral DOT DecimalIntegerLiteral? (('e') DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
		//|'pi'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////( MINUS? DecimalIntegerLiteral DOT DecimalIntegerLiteral? ((('e-' | 'e')) DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
		//( DecimalIntegerLiteral DOT DecimalIntegerLiteral? (('e') DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
		public Group getGroup_0() { return cGroup_0; }
		
		//DecimalIntegerLiteral
		public RuleCall getDecimalIntegerLiteralParserRuleCall_0_0() { return cDecimalIntegerLiteralParserRuleCall_0_0; }
		
		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }
		
		//DecimalIntegerLiteral?
		public RuleCall getDecimalIntegerLiteralParserRuleCall_0_2() { return cDecimalIntegerLiteralParserRuleCall_0_2; }
		
		//(('e') DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//('e')
		public Keyword getEKeyword_0_3_0() { return cEKeyword_0_3_0; }
		
		//DecimalIntegerLiteral
		public RuleCall getDecimalIntegerLiteralParserRuleCall_0_3_1() { return cDecimalIntegerLiteralParserRuleCall_0_3_1; }
		
		//(DOT DecimalIntegerLiteral)?
		public Group getGroup_0_3_2() { return cGroup_0_3_2; }
		
		//DOT
		public RuleCall getDOTTerminalRuleCall_0_3_2_0() { return cDOTTerminalRuleCall_0_3_2_0; }
		
		//DecimalIntegerLiteral
		public RuleCall getDecimalIntegerLiteralParserRuleCall_0_3_2_1() { return cDecimalIntegerLiteralParserRuleCall_0_3_2_1; }
		
		//'pi'
		public Keyword getPiKeyword_1() { return cPiKeyword_1; }
	}
	public class DecimalIntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.DecimalIntegerLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMINUSTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//DecimalIntegerLiteral:
		//    (MINUS)? INT
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(MINUS)? INT
		public Group getGroup() { return cGroup; }
		
		//(MINUS)?
		public RuleCall getMINUSTerminalRuleCall_0() { return cMINUSTerminalRuleCall_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class IncludeStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.IncludeStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIncludeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLibNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLibNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cLibNameAssignment_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//IncludeStatement:
		//    'include' libName=STRING SEMICOLON
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'include' libName=STRING SEMICOLON
		public Group getGroup() { return cGroup; }
		
		//'include'
		public Keyword getIncludeKeyword_0() { return cIncludeKeyword_0; }
		
		//libName=STRING
		public Assignment getLibNameAssignment_1() { return cLibNameAssignment_1; }
		
		//STRING
		public RuleCall getLibNameSTRINGTerminalRuleCall_1_0() { return cLibNameSTRINGTerminalRuleCall_1_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2() { return cSEMICOLONTerminalRuleCall_2; }
	}
	
	
	private final ProgramElements pProgram;
	private final VersionElements pVersion;
	private final StatementElements pStatement;
	private final QuantumDeclarationStatementElements pQuantumDeclarationStatement;
	private final GateCallStatementElements pGateCallStatement;
	private final IfStatementElements pIfStatement;
	private final StatementOrScopeElements pStatementOrScope;
	private final ScopeElements pScope;
	private final ExpressionListElements pExpressionList;
	private final ExpressionElements pExpression;
	private final LiteralElements pLiteral;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final MultiplicativeOperatorElements pMultiplicativeOperator;
	private final UnaryExpressionElements pUnaryExpression;
	private final UnaryOperatorElements pUnaryOperator;
	private final IndexOperatorElements pIndexOperator;
	private final IndexedIdentifierElements pIndexedIdentifier;
	private final GateOperandElements pGateOperand;
	private final GateOperandListElements pGateOperandList;
	private final QubitTypeElements pQubitType;
	private final DesignatorElements pDesignator;
	private final FloatLiteralElements pFloatLiteral;
	private final DecimalIntegerLiteralElements pDecimalIntegerLiteral;
	private final IncludeStatementElements pIncludeStatement;
	private final TerminalRule tELSE;
	private final TerminalRule tMINUS;
	private final TerminalRule tEXCLAMATION_POINT;
	private final TerminalRule tTILDE;
	private final TerminalRule tPERCENT;
	private final TerminalRule tSLASH;
	private final TerminalRule tASTERISK;
	private final TerminalRule tDOT;
	private final TerminalRule tCOMMA;
	private final TerminalRule tBIT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tANGLE;
	private final TerminalRule tBOOL;
	private final TerminalRule tDURATION;
	private final TerminalRule tSTRETCH;
	private final TerminalRule tCOMPLEX;
	private final TerminalRule tARRAY;
	private final TerminalRule tQUBIT;
	private final TerminalRule tLBRACKET;
	private final TerminalRule tRBRACKET;
	private final TerminalRule tSEMICOLON;
	private final TerminalRule tLPAREN;
	private final TerminalRule tRPAREN;
	private final TerminalRule tLBRACE;
	private final TerminalRule tRBRACE;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public OpenQASM3GrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.pVersion = new VersionElements();
		this.pStatement = new StatementElements();
		this.pQuantumDeclarationStatement = new QuantumDeclarationStatementElements();
		this.pGateCallStatement = new GateCallStatementElements();
		this.pIfStatement = new IfStatementElements();
		this.pStatementOrScope = new StatementOrScopeElements();
		this.pScope = new ScopeElements();
		this.pExpressionList = new ExpressionListElements();
		this.pExpression = new ExpressionElements();
		this.pLiteral = new LiteralElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pMultiplicativeOperator = new MultiplicativeOperatorElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pUnaryOperator = new UnaryOperatorElements();
		this.pIndexOperator = new IndexOperatorElements();
		this.pIndexedIdentifier = new IndexedIdentifierElements();
		this.pGateOperand = new GateOperandElements();
		this.pGateOperandList = new GateOperandListElements();
		this.pQubitType = new QubitTypeElements();
		this.pDesignator = new DesignatorElements();
		this.pFloatLiteral = new FloatLiteralElements();
		this.pDecimalIntegerLiteral = new DecimalIntegerLiteralElements();
		this.pIncludeStatement = new IncludeStatementElements();
		this.tELSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.ELSE");
		this.tMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.MINUS");
		this.tEXCLAMATION_POINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.EXCLAMATION_POINT");
		this.tTILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.TILDE");
		this.tPERCENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.PERCENT");
		this.tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.SLASH");
		this.tASTERISK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.ASTERISK");
		this.tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.DOT");
		this.tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.COMMA");
		this.tBIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.BIT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.FLOAT");
		this.tANGLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.ANGLE");
		this.tBOOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.BOOL");
		this.tDURATION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.DURATION");
		this.tSTRETCH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.STRETCH");
		this.tCOMPLEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.COMPLEX");
		this.tARRAY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.ARRAY");
		this.tQUBIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.QUBIT");
		this.tLBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.LBRACKET");
		this.tRBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.RBRACKET");
		this.tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.SEMICOLON");
		this.tLPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.LPAREN");
		this.tRPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.RPAREN");
		this.tLBRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.LBRACE");
		this.tRBRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.openqasm.OpenQASM3.RBRACE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.openqasm.OpenQASM3".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Program:
	//    version=Version?
	//    statements+=(Statement)*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//Version:
	//    ('OPENQASM' versionNumber=FloatLiteral) SEMICOLON
	//;
	public VersionElements getVersionAccess() {
		return pVersion;
	}
	
	public ParserRule getVersionRule() {
		return getVersionAccess().getRule();
	}
	
	//Statement:
	//    IncludeStatement
	//    |quantumDeclarationStatement
	//    |GateCallStatement
	//    |IfStatement
	//;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//quantumDeclarationStatement:
	//    QubitType name=ID SEMICOLON
	//;
	public QuantumDeclarationStatementElements getQuantumDeclarationStatementAccess() {
		return pQuantumDeclarationStatement;
	}
	
	public ParserRule getQuantumDeclarationStatementRule() {
		return getQuantumDeclarationStatementAccess().getRule();
	}
	
	//GateCallStatement:
	//    ('gate')? gate=ID (LPAREN el=ExpressionList? RPAREN)? gateList=GateOperandList (( scope=Scope| SEMICOLON ))
	//;
	public GateCallStatementElements getGateCallStatementAccess() {
		return pGateCallStatement;
	}
	
	public ParserRule getGateCallStatementRule() {
		return getGateCallStatementAccess().getRule();
	}
	
	//IfStatement:
	//    'if' LPAREN condition=Expression RPAREN if_body=statementOrScope;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	// //(ELSE else_body=statementOrScope)?;
	//statementOrScope:
	//    Statement|Scope
	//;
	public StatementOrScopeElements getStatementOrScopeAccess() {
		return pStatementOrScope;
	}
	
	public ParserRule getStatementOrScopeRule() {
		return getStatementOrScopeAccess().getRule();
	}
	
	//Scope:
	//    {Scope} LBRACE statements+=Statement* RBRACE;
	public ScopeElements getScopeAccess() {
		return pScope;
	}
	
	public ParserRule getScopeRule() {
		return getScopeAccess().getRule();
	}
	
	//ExpressionList:
	//    e1=Expression (COMMA e2+=Expression)* COMMA?
	//;
	public ExpressionListElements getExpressionListAccess() {
		return pExpressionList;
	}
	
	public ParserRule getExpressionListRule() {
		return getExpressionListAccess().getRule();
	}
	
	//Expression:
	//    LPAREN exprs+=Expression RPAREN
	//    | ltrs+=Literal
	//    | unExpressions+=UnaryExpression
	//    | multExpressions+=MultiplicativeExpression
	//;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Literal:
	//    l= FloatLiteral
	//    | {Literal} STRING
	//    | {Literal} DecimalIntegerLiteral
	//;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//MultiplicativeExpression:
	//    l1+=Literal MultiplicativeOperator l1+=Literal (MultiplicativeOperator l1+=Literal)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//MultiplicativeOperator:
	//    ASTERISK | SLASH
	//;
	public MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return pMultiplicativeOperator;
	}
	
	public ParserRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}
	
	//UnaryExpression:
	//    (op=UnaryOperator) l=Literal;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//UnaryOperator:
	//    TILDE | EXCLAMATION_POINT;
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return pUnaryOperator;
	}
	
	public ParserRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//IndexOperator:
	//    LBRACKET
	//    (
	//        Expression (COMMA e+=Expression)* COMMA?
	//    )
	//    RBRACKET
	//;
	public IndexOperatorElements getIndexOperatorAccess() {
		return pIndexOperator;
	}
	
	public ParserRule getIndexOperatorRule() {
		return getIndexOperatorAccess().getRule();
	}
	
	//IndexedIdentifier:
	//    gateName=ID (io+=IndexOperator)*
	//;
	public IndexedIdentifierElements getIndexedIdentifierAccess() {
		return pIndexedIdentifier;
	}
	
	public ParserRule getIndexedIdentifierRule() {
		return getIndexedIdentifierAccess().getRule();
	}
	
	//GateOperand:
	//    IndexedIdentifier
	//;
	public GateOperandElements getGateOperandAccess() {
		return pGateOperand;
	}
	
	public ParserRule getGateOperandRule() {
		return getGateOperandAccess().getRule();
	}
	
	//GateOperandList:
	//    GateOperand (COMMA extraGO+=GateOperand)* COMMA?
	//;
	public GateOperandListElements getGateOperandListAccess() {
		return pGateOperandList;
	}
	
	public ParserRule getGateOperandListRule() {
		return getGateOperandListAccess().getRule();
	}
	
	//QubitType:
	//     QUBIT d=Designator;
	public QubitTypeElements getQubitTypeAccess() {
		return pQubitType;
	}
	
	public ParserRule getQubitTypeRule() {
		return getQubitTypeAccess().getRule();
	}
	
	//Designator:
	//    {Designator} LBRACKET e=Expression? RBRACKET
	//;
	public DesignatorElements getDesignatorAccess() {
		return pDesignator;
	}
	
	public ParserRule getDesignatorRule() {
		return getDesignatorAccess().getRule();
	}
	
	//FloatLiteral:
	//    //( MINUS? DecimalIntegerLiteral DOT DecimalIntegerLiteral? ((('e-' | 'e')) DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
	//    ( DecimalIntegerLiteral DOT DecimalIntegerLiteral? (('e') DecimalIntegerLiteral (DOT DecimalIntegerLiteral)?)?)
	//    |'pi'
	//;
	public FloatLiteralElements getFloatLiteralAccess() {
		return pFloatLiteral;
	}
	
	public ParserRule getFloatLiteralRule() {
		return getFloatLiteralAccess().getRule();
	}
	
	//DecimalIntegerLiteral:
	//    (MINUS)? INT
	//;
	public DecimalIntegerLiteralElements getDecimalIntegerLiteralAccess() {
		return pDecimalIntegerLiteral;
	}
	
	public ParserRule getDecimalIntegerLiteralRule() {
		return getDecimalIntegerLiteralAccess().getRule();
	}
	
	//IncludeStatement:
	//    'include' libName=STRING SEMICOLON
	//;
	public IncludeStatementElements getIncludeStatementAccess() {
		return pIncludeStatement;
	}
	
	public ParserRule getIncludeStatementRule() {
		return getIncludeStatementAccess().getRule();
	}
	
	//terminal ELSE:'else';
	public TerminalRule getELSERule() {
		return tELSE;
	}
	
	//terminal MINUS:'-';
	public TerminalRule getMINUSRule() {
		return tMINUS;
	}
	
	//terminal EXCLAMATION_POINT:'!';
	public TerminalRule getEXCLAMATION_POINTRule() {
		return tEXCLAMATION_POINT;
	}
	
	//terminal TILDE:'~';
	public TerminalRule getTILDERule() {
		return tTILDE;
	}
	
	//terminal PERCENT: '%';
	public TerminalRule getPERCENTRule() {
		return tPERCENT;
	}
	
	//terminal SLASH:'/';
	public TerminalRule getSLASHRule() {
		return tSLASH;
	}
	
	//terminal ASTERISK:'*';
	public TerminalRule getASTERISKRule() {
		return tASTERISK;
	}
	
	//terminal DOT:	'.';
	public TerminalRule getDOTRule() {
		return tDOT;
	}
	
	//terminal COMMA:	',';
	public TerminalRule getCOMMARule() {
		return tCOMMA;
	}
	
	//terminal BIT: 'bit';
	public TerminalRule getBITRule() {
		return tBIT;
	}
	
	//terminal FLOAT: 'float';
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal ANGLE: 'angle';
	public TerminalRule getANGLERule() {
		return tANGLE;
	}
	
	//terminal BOOL: 'bool';
	public TerminalRule getBOOLRule() {
		return tBOOL;
	}
	
	//terminal DURATION: 'duration';
	public TerminalRule getDURATIONRule() {
		return tDURATION;
	}
	
	//terminal STRETCH: 'stretch';
	public TerminalRule getSTRETCHRule() {
		return tSTRETCH;
	}
	
	//terminal COMPLEX: 'complex';
	public TerminalRule getCOMPLEXRule() {
		return tCOMPLEX;
	}
	
	//terminal ARRAY: 'array';
	public TerminalRule getARRAYRule() {
		return tARRAY;
	}
	
	//terminal QUBIT: 'qubit';
	public TerminalRule getQUBITRule() {
		return tQUBIT;
	}
	
	//terminal LBRACKET: '[';
	public TerminalRule getLBRACKETRule() {
		return tLBRACKET;
	}
	
	//terminal RBRACKET: ']';
	public TerminalRule getRBRACKETRule() {
		return tRBRACKET;
	}
	
	//terminal SEMICOLON: ';';
	public TerminalRule getSEMICOLONRule() {
		return tSEMICOLON;
	}
	
	//terminal LPAREN: '(';
	public TerminalRule getLPARENRule() {
		return tLPAREN;
	}
	
	//terminal RPAREN: ')';
	public TerminalRule getRPARENRule() {
		return tRPAREN;
	}
	
	//terminal LBRACE: '{';
	public TerminalRule getLBRACERule() {
		return tLBRACE;
	}
	
	//terminal RBRACE: '}';
	public TerminalRule getRBRACERule() {
		return tRBRACE;
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
